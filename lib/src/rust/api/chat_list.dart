// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;

import '../frb_generated.dart';
import 'error.dart';
import 'groups.dart';
import 'messages.dart';

part 'chat_list.freezed.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `from`, `from`, `from`

/// Sets the pin order for a chat.
///
/// Pinned chats appear before unpinned chats in the chat list.
/// Lower pin_order values appear first among pinned chats.
///
/// - `pin_order = None` = unpin the chat
/// - `pin_order = Some(n)` = pin the chat with order n
Future<void> setChatPinOrder({
  required String accountPubkey,
  required String mlsGroupId,
  PlatformInt64? pinOrder,
}) => RustLib.instance.api.crateApiChatListSetChatPinOrder(
  accountPubkey: accountPubkey,
  mlsGroupId: mlsGroupId,
  pinOrder: pinOrder,
);

/// Retrieves the chat list for an account.
///
/// Returns a list of chat summaries sorted by:
/// 1. Pinned chats first (sorted by pin_order, lower values first)
/// 2. Unpinned chats sorted by last activity (most recent first)
/// 3. Groups without messages are sorted by creation date
Future<List<ChatSummary>> getChatList({required String accountPubkey}) =>
    RustLib.instance.api.crateApiChatListGetChatList(
      accountPubkey: accountPubkey,
    );

/// Subscribe to real-time chat list updates for an account.
///
/// The stream first emits an `InitialSnapshot` containing all current chats,
/// then emits `Update` items as chats are created, receive new messages, or have messages deleted.
///
/// The initial snapshot is race-condition free: any updates that arrive between
/// subscribing and fetching are merged into the snapshot.
Stream<ChatListStreamItem> subscribeToChatList({
  required String accountPubkey,
}) => RustLib.instance.api.crateApiChatListSubscribeToChatList(
  accountPubkey: accountPubkey,
);

@freezed
sealed class ChatListStreamItem with _$ChatListStreamItem {
  const ChatListStreamItem._();

  /// Initial snapshot of all chats at subscription time
  const factory ChatListStreamItem.initialSnapshot({
    required List<ChatSummary> items,
  }) = ChatListStreamItem_InitialSnapshot;

  /// Real-time update for a single chat
  const factory ChatListStreamItem.update({
    required ChatListUpdate update,
  }) = ChatListStreamItem_Update;
}

/// A real-time update for the chat list.
///
/// Contains the trigger indicating what changed and the complete,
/// current state of the affected chat item.
class ChatListUpdate {
  final ChatListUpdateTrigger trigger;
  final ChatSummary item;

  const ChatListUpdate({
    required this.trigger,
    required this.item,
  });

  @override
  int get hashCode => trigger.hashCode ^ item.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ChatListUpdate &&
          runtimeType == other.runtimeType &&
          trigger == other.trigger &&
          item == other.item;
}

/// What triggered a chat list update in the stream.
enum ChatListUpdateTrigger {
  /// A new group was created or joined
  newGroup,

  /// A new message updated the chat's last message preview
  newLastMessage,

  /// The last message in a chat was deleted
  lastMessageDeleted,
}

class ChatSummary {
  /// MLS group identifier (hex string)
  final String mlsGroupId;

  /// Display name for this chat:
  /// - Groups: The group name (may be empty)
  /// - DMs: The other user's display name (None if no metadata)
  final String? name;

  /// Type of chat: Group or DirectMessage
  final GroupType groupType;

  /// When this group was created
  final DateTime createdAt;

  /// Path to cached decrypted group image (Groups only)
  final String? groupImagePath;

  /// Profile picture URL of the other user (DMs only)
  final String? groupImageUrl;

  /// Preview of the last message (None if no messages)
  final ChatMessageSummary? lastMessage;

  /// Whether the group is pending user confirmation
  final bool pendingConfirmation;

  /// Public key (hex) of the user who invited this account to the group.
  /// `Some` when invited by another user, `None` when the user created the group.
  final String? welcomerPubkey;

  /// Number of unread messages in this chat
  final BigInt unreadCount;

  /// Pin order for chat list sorting.
  /// - `None` = not pinned (appears after pinned chats)
  /// - `Some(n)` = pinned, lower values appear first
  final PlatformInt64? pinOrder;

  const ChatSummary({
    required this.mlsGroupId,
    this.name,
    required this.groupType,
    required this.createdAt,
    this.groupImagePath,
    this.groupImageUrl,
    this.lastMessage,
    required this.pendingConfirmation,
    this.welcomerPubkey,
    required this.unreadCount,
    this.pinOrder,
  });

  @override
  int get hashCode =>
      mlsGroupId.hashCode ^
      name.hashCode ^
      groupType.hashCode ^
      createdAt.hashCode ^
      groupImagePath.hashCode ^
      groupImageUrl.hashCode ^
      lastMessage.hashCode ^
      pendingConfirmation.hashCode ^
      welcomerPubkey.hashCode ^
      unreadCount.hashCode ^
      pinOrder.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ChatSummary &&
          runtimeType == other.runtimeType &&
          mlsGroupId == other.mlsGroupId &&
          name == other.name &&
          groupType == other.groupType &&
          createdAt == other.createdAt &&
          groupImagePath == other.groupImagePath &&
          groupImageUrl == other.groupImageUrl &&
          lastMessage == other.lastMessage &&
          pendingConfirmation == other.pendingConfirmation &&
          welcomerPubkey == other.welcomerPubkey &&
          unreadCount == other.unreadCount &&
          pinOrder == other.pinOrder;
}
