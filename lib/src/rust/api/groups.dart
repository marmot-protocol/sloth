// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

import '../frb_generated.dart';
import '../lib.dart';
import 'error.dart';
import 'messages.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from`, `from`, `from`, `from`, `from`, `from`

Future<List<Group>> activeGroups({required String pubkey}) =>
    RustLib.instance.api.crateApiGroupsActiveGroups(pubkey: pubkey);

Future<List<String>> groupMembers({
  required String pubkey,
  required String groupId,
}) => RustLib.instance.api.crateApiGroupsGroupMembers(
  pubkey: pubkey,
  groupId: groupId,
);

Future<List<String>> groupAdmins({
  required String pubkey,
  required String groupId,
}) => RustLib.instance.api.crateApiGroupsGroupAdmins(
  pubkey: pubkey,
  groupId: groupId,
);

Future<Group> createGroup({
  required String creatorPubkey,
  required List<String> memberPubkeys,
  required List<String> adminPubkeys,
  required String groupName,
  required String groupDescription,
  required GroupType groupType,
}) => RustLib.instance.api.crateApiGroupsCreateGroup(
  creatorPubkey: creatorPubkey,
  memberPubkeys: memberPubkeys,
  adminPubkeys: adminPubkeys,
  groupName: groupName,
  groupDescription: groupDescription,
  groupType: groupType,
);

Future<void> addMembersToGroup({
  required String pubkey,
  required String groupId,
  required List<String> memberPubkeys,
}) => RustLib.instance.api.crateApiGroupsAddMembersToGroup(
  pubkey: pubkey,
  groupId: groupId,
  memberPubkeys: memberPubkeys,
);

Future<void> removeMembersFromGroup({
  required String pubkey,
  required String groupId,
  required List<String> memberPubkeys,
}) => RustLib.instance.api.crateApiGroupsRemoveMembersFromGroup(
  pubkey: pubkey,
  groupId: groupId,
  memberPubkeys: memberPubkeys,
);

Future<Group> getGroup({
  required String accountPubkey,
  required String groupId,
}) => RustLib.instance.api.crateApiGroupsGetGroup(
  accountPubkey: accountPubkey,
  groupId: groupId,
);

Future<GroupInformation> getGroupInformation({
  required String accountPubkey,
  required String groupId,
}) => RustLib.instance.api.crateApiGroupsGetGroupInformation(
  accountPubkey: accountPubkey,
  groupId: groupId,
);

Future<List<GroupInformation>> getGroupsInformations({
  required String accountPubkey,
  required List<String> groupIds,
}) => RustLib.instance.api.crateApiGroupsGetGroupsInformations(
  accountPubkey: accountPubkey,
  groupIds: groupIds,
);

/// Retrieves the chat list for an account.
///
/// Returns a list of chat summaries sorted by last activity (most recent first).
/// Groups without messages are sorted by creation date.
Future<List<ChatSummary>> getChatList({required String accountPubkey}) =>
    RustLib.instance.api.crateApiGroupsGetChatList(
      accountPubkey: accountPubkey,
    );

Future<UploadGroupImageResult> uploadGroupImage({
  required String accountPubkey,
  required String groupId,
  required String filePath,
  required String serverUrl,
}) => RustLib.instance.api.crateApiGroupsUploadGroupImage(
  accountPubkey: accountPubkey,
  groupId: groupId,
  filePath: filePath,
  serverUrl: serverUrl,
);

Future<String?> getGroupImagePath({
  required String accountPubkey,
  required String groupId,
}) => RustLib.instance.api.crateApiGroupsGetGroupImagePath(
  accountPubkey: accountPubkey,
  groupId: groupId,
);

/// Summary of a chat/group for the chat list screen.
///
/// Contains pre-computed display data (resolved names, images, last message).
class ChatSummary {
  /// MLS group identifier (hex string)
  final String mlsGroupId;

  /// Display name for this chat:
  /// - Groups: The group name (may be empty)
  /// - DMs: The other user's display name (None if no metadata)
  final String? name;

  /// Type of chat: Group or DirectMessage
  final GroupType groupType;

  /// When this group was created
  final DateTime createdAt;

  /// Path to cached decrypted group image (Groups only)
  final String? groupImagePath;

  /// Profile picture URL of the other user (DMs only)
  final String? groupImageUrl;

  /// Preview of the last message (None if no messages)
  final ChatMessageSummary? lastMessage;

  /// Whether the group is pending user confirmation
  final bool pendingConfirmation;

  const ChatSummary({
    required this.mlsGroupId,
    this.name,
    required this.groupType,
    required this.createdAt,
    this.groupImagePath,
    this.groupImageUrl,
    this.lastMessage,
    required this.pendingConfirmation,
  });

  @override
  int get hashCode =>
      mlsGroupId.hashCode ^
      name.hashCode ^
      groupType.hashCode ^
      createdAt.hashCode ^
      groupImagePath.hashCode ^
      groupImageUrl.hashCode ^
      lastMessage.hashCode ^
      pendingConfirmation.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ChatSummary &&
          runtimeType == other.runtimeType &&
          mlsGroupId == other.mlsGroupId &&
          name == other.name &&
          groupType == other.groupType &&
          createdAt == other.createdAt &&
          groupImagePath == other.groupImagePath &&
          groupImageUrl == other.groupImageUrl &&
          lastMessage == other.lastMessage &&
          pendingConfirmation == other.pendingConfirmation;
}

class FlutterGroupDataUpdate {
  final String? name;
  final String? description;
  final List<String>? relays;
  final List<String>? admins;
  final U8Array32? imageKey;
  final U8Array32? imageHash;
  final U8Array12? imageNonce;

  const FlutterGroupDataUpdate({
    this.name,
    this.description,
    this.relays,
    this.admins,
    this.imageKey,
    this.imageHash,
    this.imageNonce,
  });

  @override
  int get hashCode =>
      name.hashCode ^
      description.hashCode ^
      relays.hashCode ^
      admins.hashCode ^
      imageKey.hashCode ^
      imageHash.hashCode ^
      imageNonce.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FlutterGroupDataUpdate &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          description == other.description &&
          relays == other.relays &&
          admins == other.admins &&
          imageKey == other.imageKey &&
          imageHash == other.imageHash &&
          imageNonce == other.imageNonce;
}

class Group {
  final String mlsGroupId;
  final String nostrGroupId;
  final String name;
  final String description;
  final U8Array32? imageHash;
  final U8Array32? imageKey;
  final List<String> adminPubkeys;
  final String? lastMessageId;
  final DateTime? lastMessageAt;
  final BigInt epoch;
  final GroupState state;

  const Group({
    required this.mlsGroupId,
    required this.nostrGroupId,
    required this.name,
    required this.description,
    this.imageHash,
    this.imageKey,
    required this.adminPubkeys,
    this.lastMessageId,
    this.lastMessageAt,
    required this.epoch,
    required this.state,
  });

  Future<GroupType> groupType({required String accountPubkey}) =>
      RustLib.instance.api.crateApiGroupsGroupGroupType(that: this, accountPubkey: accountPubkey);

  Future<bool> isDirectMessageType({required String accountPubkey}) =>
      RustLib.instance.api.crateApiGroupsGroupIsDirectMessageType(
        that: this,
        accountPubkey: accountPubkey,
      );

  Future<bool> isGroupType({required String accountPubkey}) =>
      RustLib.instance.api.crateApiGroupsGroupIsGroupType(that: this, accountPubkey: accountPubkey);

  Future<void> updateGroupData({
    required String accountPubkey,
    required FlutterGroupDataUpdate groupData,
  }) => RustLib.instance.api.crateApiGroupsGroupUpdateGroupData(
    that: this,
    accountPubkey: accountPubkey,
    groupData: groupData,
  );

  @override
  int get hashCode =>
      mlsGroupId.hashCode ^
      nostrGroupId.hashCode ^
      name.hashCode ^
      description.hashCode ^
      imageHash.hashCode ^
      imageKey.hashCode ^
      adminPubkeys.hashCode ^
      lastMessageId.hashCode ^
      lastMessageAt.hashCode ^
      epoch.hashCode ^
      state.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Group &&
          runtimeType == other.runtimeType &&
          mlsGroupId == other.mlsGroupId &&
          nostrGroupId == other.nostrGroupId &&
          name == other.name &&
          description == other.description &&
          imageHash == other.imageHash &&
          imageKey == other.imageKey &&
          adminPubkeys == other.adminPubkeys &&
          lastMessageId == other.lastMessageId &&
          lastMessageAt == other.lastMessageAt &&
          epoch == other.epoch &&
          state == other.state;
}

class GroupInformation {
  final String mlsGroupId;
  final GroupType groupType;
  final DateTime createdAt;
  final DateTime updatedAt;

  const GroupInformation({
    required this.mlsGroupId,
    required this.groupType,
    required this.createdAt,
    required this.updatedAt,
  });

  @override
  int get hashCode =>
      mlsGroupId.hashCode ^ groupType.hashCode ^ createdAt.hashCode ^ updatedAt.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GroupInformation &&
          runtimeType == other.runtimeType &&
          mlsGroupId == other.mlsGroupId &&
          groupType == other.groupType &&
          createdAt == other.createdAt &&
          updatedAt == other.updatedAt;
}

enum GroupState {
  active,
  inactive,
  pending,
}

enum GroupType {
  directMessage,
  group,
}

class UploadGroupImageResult {
  final U8Array32 encryptedHash;
  final U8Array32 imageKey;
  final U8Array12 imageNonce;

  const UploadGroupImageResult({
    required this.encryptedHash,
    required this.imageKey,
    required this.imageNonce,
  });

  @override
  int get hashCode => encryptedHash.hashCode ^ imageKey.hashCode ^ imageNonce.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UploadGroupImageResult &&
          runtimeType == other.runtimeType &&
          encryptedHash == other.encryptedHash &&
          imageKey == other.imageKey &&
          imageNonce == other.imageNonce;
}
