import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:whitenoise/l10n/l10n.dart';
import 'package:whitenoise/providers/account_pubkey_provider.dart';
import 'package:whitenoise/providers/locale_provider.dart';
import 'package:whitenoise/routes.dart' show Routes;
import 'package:whitenoise/services/user_service.dart';
import 'package:whitenoise/src/rust/api/chat_list.dart' show ChatSummary;
import 'package:whitenoise/src/rust/api/groups.dart' show GroupType;
import 'package:whitenoise/utils/metadata.dart';
import 'package:whitenoise/widgets/wn_avatar.dart';
import 'package:whitenoise/widgets/wn_chat_list_item.dart';
import 'package:whitenoise/widgets/wn_chat_status.dart';

class ChatListTile extends HookConsumerWidget {
  final ChatSummary chatSummary;

  const ChatListTile({super.key, required this.chatSummary});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final formatters = ref.watch(localeFormattersProvider);
    final myPubkey = ref.watch(accountPubkeyProvider);
    final isDm = chatSummary.groupType == GroupType.directMessage;
    final isPending = chatSummary.pendingConfirmation;
    final hasWelcomer = chatSummary.welcomerPubkey != null;

    final welcomerMetadata = useMemoized(() async {
      if (!isPending || !hasWelcomer) return null;

      try {
        return UserService(chatSummary.welcomerPubkey!).fetchMetadata();
      } catch (_) {
        return null;
      }
    }, [chatSummary.welcomerPubkey, isPending, hasWelcomer]);
    final welcomerSnapshot = useFuture(welcomerMetadata);

    final hasGroupName = chatSummary.name?.isNotEmpty ?? false;
    final welcomerName = presentName(welcomerSnapshot.data);

    final String title;
    final String? pictureUrl;
    final String subtitle;
    final String? avatarName;

    if (isPending) {
      if (isDm) {
        title = welcomerName ?? chatSummary.name ?? context.l10n.unknownUser;
        pictureUrl = welcomerSnapshot.data?.picture ?? chatSummary.groupImageUrl;
        avatarName = welcomerName ?? chatSummary.name;
        subtitle = context.l10n.hasInvitedYouToSecureChat;
      } else {
        title = hasGroupName ? chatSummary.name! : context.l10n.unknownGroup;
        pictureUrl = chatSummary.groupImagePath;
        avatarName = hasGroupName ? chatSummary.name! : null;
        if (welcomerName != null) {
          subtitle = context.l10n.userInvitedYouToSecureChat(welcomerName);
        } else {
          subtitle = context.l10n.youHaveBeenInvitedToSecureChat;
        }
      }
    } else {
      if (isDm) {
        title = hasGroupName ? chatSummary.name! : context.l10n.unknownUser;
        pictureUrl = chatSummary.groupImageUrl;
      } else {
        title = hasGroupName ? chatSummary.name! : context.l10n.unknownGroup;
        pictureUrl = chatSummary.groupImagePath;
      }
      avatarName = hasGroupName ? chatSummary.name! : null;
      subtitle = chatSummary.lastMessage?.content ?? '';
    }

    final timestamp = chatSummary.lastMessage?.createdAt ?? chatSummary.createdAt;
    final formattedTime = formatters.formatRelativeTime(
      timestamp,
      context.l10n,
    );

    ChatStatusType? status;
    final unreadCount = chatSummary.unreadCount.toInt();
    if (isPending) {
      status = ChatStatusType.request;
    } else if (unreadCount > 0) {
      status = ChatStatusType.unreadCount;
    }

    String? prefixSubtitle;
    if (!isPending && chatSummary.lastMessage?.author == myPubkey) {
      prefixSubtitle = '${context.l10n.you}: ';
    }

    final avatarColorKey = isDm
        ? (chatSummary.dmPeerPubkey ?? chatSummary.mlsGroupId)
        : chatSummary.mlsGroupId;

    return WnChatListItem(
      key: ValueKey(chatSummary.mlsGroupId),
      onTap: isPending
          ? () => Routes.pushToInvite(context, chatSummary.mlsGroupId)
          : () => Routes.goToChat(context, chatSummary.mlsGroupId),
      title: title,
      subtitle: subtitle,
      timestamp: formattedTime,
      avatarUrl: pictureUrl,
      avatarName: avatarName,
      avatarColor: AvatarColor.fromPubkey(avatarColorKey),
      status: status,
      unreadCount: unreadCount,
      prefixSubtitle: prefixSubtitle,
    );
  }
}
